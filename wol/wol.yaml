# Конфигурация ESPHome для управления питанием ПК# Автор: Hayo-Tee (https://github.com/Hayo-Tee)# Последнее обновление: 2025-03-03 04:39:10 UTCsubstitutions:  power_relay_gpio: "4"     # Управление питанием  reset_relay_gpio: "6"     # Управление сбросом  power_sense_gpio: "5"     # Датчик состояния питания (LED)  power_button_gpio: "3"    # Физическая кнопка питания  reset_sense_gpio: "7"     # Датчик сбросаesphome:  name: "wol"  friendly_name: WOL  name_add_mac_suffix: false  project:    name: "Hayo-Tee.WOL"    version: "1.0.0"  platformio_options:    upload_speed: 57600    board_build.f_cpu: 40000000L    board_build.flash_mode: dout    board_build.flash_size: 4MB    platform: espressif32@3.5.0    build_flags:       - "-DCORE_DEBUG_LEVEL=5"      - "-DARDUINO_USB_MODE=1"      - "-DARDUINO_USB_CDC_ON_BOOT=1"  on_boot:    priority: -100    then:      - delay: 1s      - switch.turn_off: power_relay      - switch.turn_off: reset_relay      - logger.log: "Устройство загружено, реле инициализированы в состояние ВЫКЛ"esp32:  board: esp32-c3-devkitm-1  framework:    type: arduino  variant: esp32c3logger:  level: VERBOSE  baud_rate: 115200api:  encryption:    key: !secret api_encryption_key  reboot_timeout: 0swifi:  ssid: !secret wifi_ssid  password: !secret wifi_password  power_save_mode: none  output_power: 20dB  fast_connect: true    ap:    ssid: "WOL-Fallback"    password: !secret fallback_password  reboot_timeout: 15mincaptive_portal:mdns:  disabled: false  services:    - service: _esphomelib      protocol: _tcp      port: 6052    - service: _http      protocol: _tcp      port: 6052web_server:  port: 6052globals:  - id: target_mac    type: std::string    initial_value: !secret default_mac  - id: press_mode    type: int    initial_value: '0'  # 0 - короткое, 1 - выключение, 2 - принудительноеbinary_sensor:  - platform: gpio    name: "Статус питания ПК"    pin:      number: ${power_sense_gpio}      mode: INPUT_PULLUP      inverted: true    id: pc_power_status    device_class: power    filters:      - delayed_on: 100ms      - delayed_off: 100ms    on_state:      then:        - logger.log:             format: "Состояние питания ПК изменено на %s"            args: ['id(pc_power_status).state ? "ВКЛ" : "ВЫКЛ"']  - platform: gpio    name: "Физическая кнопка питания ПК"    pin:      number: ${power_button_gpio}      mode: INPUT_PULLUP      inverted: true    on_press:      then:        - switch.turn_on: power_control        - logger.log: "Нажата физическая кнопка питания"    filters:      - delayed_on: 50ms      - delayed_off: 50ms  - platform: gpio    name: "Физическая кнопка сброса ПК"    pin:      number: ${reset_sense_gpio}      mode: INPUT_PULLUP      inverted: true    on_press:      then:        - switch.turn_on: reset_control        - logger.log: "Нажата физическая кнопка сброса"    filters:      - delayed_on: 50ms      - delayed_off: 50ms  - platform: status    name: "Статус контроллера ПК"text_sensor:  - platform: template    name: "Текущий целевой MAC"    lambda: |-      return id(target_mac);  - platform: wifi_info    ip_address:      name: IP адрес ESP    ssid:      name: Подключенная сеть    mac_address:      name: MAC адрес ESPswitch:  - platform: gpio    name: "Кнопка питания ПК"    pin:       number: ${power_relay_gpio}      inverted: true      mode: OUTPUT    id: power_relay    restore_mode: ALWAYS_OFF    internal: true      - platform: gpio    name: "Кнопка сброса ПК"    pin:      number: ${reset_relay_gpio}      inverted: true      mode: OUTPUT    id: reset_relay    restore_mode: ALWAYS_OFF    internal: true  - platform: template    name: "Управление питанием ПК"    id: power_control    turn_on_action:      - lambda: |-          static bool in_progress = false;          if (in_progress) return;          in_progress = true;                    bool pc_is_on = id(pc_power_status).state;                    if (id(press_mode) == 1 && !pc_is_on) {            ESP_LOGI("Power", "Выключение отменено - ПК уже выключен");            in_progress = false;            return;          }                    if (id(press_mode) == 0 && pc_is_on) {            ESP_LOGI("Power", "Включение отменено - ПК уже включен");            in_progress = false;            return;          }                    if (id(press_mode) == 1) {            ESP_LOGI("Power", "Выполняется последовательность выключения");          }                    id(power_relay).turn_on();                    switch (id(press_mode)) {            case 0:  // Включение              delay(500);              break;            case 1:  // Выключение              delay(4000);              break;            case 2:  // Принудительное выключение              delay(8000);              break;          }                    id(power_relay).turn_off();          delay(200);                    id(press_mode) = 0;          in_progress = false;          ESP_LOGI("Power", "Действие успешно завершено");      - logger.log: "Действие с питанием завершено"    internal: true  - platform: template    name: "Управление сбросом ПК"    id: reset_control    turn_on_action:      - lambda: |-          static bool in_progress = false;          if (in_progress) return;          in_progress = true;                    if (!id(pc_power_status).state) {            ESP_LOGI("Reset", "Сброс отменён - ПК выключен");            in_progress = false;            return;          }                    id(reset_relay).turn_on();          delay(500);                    id(reset_relay).turn_off();          delay(200);                    in_progress = false;          ESP_LOGI("Reset", "Сброс успешно выполнен");      - logger.log: "Действие сброса завершено"    internal: truebutton:  - platform: template    name: "Включить ПК"    icon: "mdi:power"    on_press:      then:        - lambda: 'id(press_mode) = 0;'        - switch.turn_on: power_control          - platform: template    name: "Выключить ПК"    icon: "mdi:power-sleep"    on_press:      then:        - lambda: 'id(press_mode) = 1;'        - switch.turn_on: power_control  - platform: template    name: "Принудительное выключение ПК"    icon: "mdi:power-off"    on_press:      then:        - lambda: 'id(press_mode) = 2;'        - switch.turn_on: power_control  - platform: template    name: "Разбудить ПК"    icon: "mdi:remote"    on_press:      then:        - script.execute: wake_pc  - platform: restart    name: "Перезагрузить ESP"    icon: "mdi:restart"  - platform: template    name: "Перезагрузить ПК"    icon: "mdi:restart-alert"    on_press:      then:        - switch.turn_on: reset_controlscript:  - id: wake_pc    then:      - lambda: |-          uint8_t mac[6];          std::string mac_str = id(target_mac);          sscanf(mac_str.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);          uint8_t magicPacket[102];          memset(magicPacket, 0xFF, 6);          for (int i = 1; i <= 16; i++) {            memcpy(&magicPacket[i * 6], mac, 6);          }          WiFiUDP udp;          udp.beginPacket("255.255.255.255", 9);          udp.write(magicPacket, sizeof(magicPacket));          udp.endPacket();          ESP_LOGI("WOL", "Wake-on-LAN пакет отправлен на: %s", mac_str.c_str());sensor:  - platform: uptime    name: "Время работы"    update_interval: 60s  - platform: wifi_signal    name: "Сигнал WiFi"    update_interval: 60stime:  - platform: homeassistant    id: homeassistant_timetext:  - platform: template    name: "Целевой MAC адрес"    id: mac_input    optimistic: true    max_length: 17    mode: text    initial_value: !secret default_mac    on_value:      then:        - lambda: |-            if (id(mac_input).state.length() == 17) {              id(target_mac) = id(mac_input).state;              ESP_LOGI("MAC", "Целевой MAC обновлен на: %s", id(mac_input).state.c_str());            }