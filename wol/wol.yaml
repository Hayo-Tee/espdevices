# ESPHome configuration for PC Power Control# Author: Hayo-Tee (https://github.com/Hayo-Tee)# Last updated: 2025-03-03 04:24:16 UTCsubstitutions:  power_relay_gpio: "4"     # Power control  reset_relay_gpio: "6"     # Reset control  power_sense_gpio: "5"     # Power status sensor (LED)  power_button_gpio: "3"    # Physical power button pin  reset_sense_gpio: "7"     # Reset sensor  default_mac: "2c:fd:a1:c6:b6:94"esphome:  name: "wol-working"  friendly_name: WOL  name_add_mac_suffix: false  project:    name: "Hayo-Tee.pc_control"    version: "1.0.0"  platformio_options:    upload_speed: 57600    board_build.f_cpu: 40000000L    board_build.flash_mode: dout    board_build.flash_size: 4MB    platform: espressif32@3.5.0    build_flags:       - "-DCORE_DEBUG_LEVEL=5"      - "-DARDUINO_USB_MODE=1"      - "-DARDUINO_USB_CDC_ON_BOOT=1"  on_boot:    priority: -100    then:      - delay: 1s      - switch.turn_off: power_relay      - switch.turn_off: reset_relay      - logger.log: "Device booted, relays initialized to OFF state"esp32:  board: esp32-c3-devkitm-1  framework:    type: arduino  variant: esp32c3logger:  level: VERBOSE  baud_rate: 115200api:  encryption:    key: "yvcev/6JMtIA13Hul/AXtmgOimmyUhp5UdPaTAgdnUo="  reboot_timeout: 0swifi:  ssid: "Hayotbek-GPON"  password: !secret wifi_password  power_save_mode: none  output_power: 20dB  fast_connect: true    ap:    ssid: "WOL-Fallback"    password: "a1MsWN520z5t"  reboot_timeout: 15mincaptive_portal:mdns:  disabled: false  services:    - service: _esphomelib      protocol: _tcp      port: 6052    - service: _http      protocol: _tcp      port: 6052web_server:  port: 6052globals:  - id: target_mac    type: std::string    initial_value: '"${default_mac}"'  - id: press_mode    type: int    initial_value: '0'  # 0 - short, 1 - shutdown, 2 - forcebinary_sensor:  - platform: gpio    name: "PC Power Status"    pin:      number: ${power_sense_gpio}      mode: INPUT_PULLUP      inverted: true    id: pc_power_status    device_class: power    filters:      - delayed_on: 100ms      - delayed_off: 100ms    on_state:      then:        - logger.log:             format: "PC power state changed to %s"            args: ['id(pc_power_status).state ? "ON" : "OFF"']  - platform: gpio    name: "PC Physical Power Button"    pin:      number: ${power_button_gpio}      mode: INPUT_PULLUP      inverted: true    on_press:      then:        - switch.turn_on: power_control        - logger.log: "Physical power button pressed"    filters:      - delayed_on: 50ms      - delayed_off: 50ms  - platform: gpio    name: "PC Physical Reset Button"    pin:      number: ${reset_sense_gpio}      mode: INPUT_PULLUP      inverted: true    on_press:      then:        - switch.turn_on: reset_control        - logger.log: "Physical reset button pressed"    filters:      - delayed_on: 50ms      - delayed_off: 50ms  - platform: status    name: "PC Control Status"text_sensor:  - platform: template    name: "Current Target MAC"    lambda: |-      return id(target_mac);  - platform: wifi_info    ip_address:      name: ESP IP Address    ssid:      name: Connected SSID    mac_address:      name: ESP MAC Addressswitch:  - platform: gpio    name: "PC Power Button"    pin:       number: ${power_relay_gpio}      inverted: true      mode: OUTPUT    id: power_relay    restore_mode: ALWAYS_OFF    internal: true      - platform: gpio    name: "PC Reset Button"    pin:      number: ${reset_relay_gpio}      inverted: true      mode: OUTPUT    id: reset_relay    restore_mode: ALWAYS_OFF    internal: true  - platform: template    name: "PC Power Control"    id: power_control    turn_on_action:      - lambda: |-          static bool in_progress = false;          if (in_progress) return;          in_progress = true;                    bool pc_is_on = id(pc_power_status).state;                    if (id(press_mode) == 1 && !pc_is_on) {            ESP_LOGI("Power", "Shutdown cancelled - PC is already OFF");            in_progress = false;            return;          }                    if (id(press_mode) == 0 && pc_is_on) {            ESP_LOGI("Power", "Power ON cancelled - PC is already ON");            in_progress = false;            return;          }                    if (id(press_mode) == 1) {            ESP_LOGI("Power", "Executing shutdown sequence");          }                    id(power_relay).turn_on();                    switch (id(press_mode)) {            case 0:  // Power On              delay(500);              break;            case 1:  // Shutdown              delay(4000);              break;            case 2:  // Force Shutdown              delay(8000);              break;          }                    id(power_relay).turn_off();          delay(200);                    id(press_mode) = 0;          in_progress = false;          ESP_LOGI("Power", "Action completed successfully");      - logger.log: "Power action completed"    internal: true  - platform: template    name: "PC Reset Control"    id: reset_control    turn_on_action:      - lambda: |-          static bool in_progress = false;          if (in_progress) return;          in_progress = true;                    if (!id(pc_power_status).state) {            ESP_LOGI("Reset", "Reset cancelled - PC is OFF");            in_progress = false;            return;          }                    id(reset_relay).turn_on();          delay(500);                    id(reset_relay).turn_off();          delay(200);                    in_progress = false;          ESP_LOGI("Reset", "Reset completed successfully");      - logger.log: "Reset action completed"    internal: truebutton:  - platform: template    name: "PC Power On"    icon: "mdi:power"    on_press:      then:        - lambda: 'id(press_mode) = 0;'        - switch.turn_on: power_control          - platform: template    name: "PC Shutdown"    icon: "mdi:power-sleep"    on_press:      then:        - lambda: 'id(press_mode) = 1;'        - switch.turn_on: power_control  - platform: template    name: "PC Force Shutdown"    icon: "mdi:power-off"    on_press:      then:        - lambda: 'id(press_mode) = 2;'        - switch.turn_on: power_control  - platform: template    name: "Wake PC"    icon: "mdi:remote"    on_press:      then:        - script.execute: wake_pc  - platform: restart    name: "Reboot ESP"    icon: "mdi:restart"  - platform: template    name: "Reboot PC"    icon: "mdi:restart-alert"    on_press:      then:        - switch.turn_on: reset_controlscript:  - id: wake_pc    then:      - lambda: |-          uint8_t mac[6];          std::string mac_str = id(target_mac);          sscanf(mac_str.c_str(), "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx", &mac[0], &mac[1], &mac[2], &mac[3], &mac[4], &mac[5]);          uint8_t magicPacket[102];          memset(magicPacket, 0xFF, 6);          for (int i = 1; i <= 16; i++) {            memcpy(&magicPacket[i * 6], mac, 6);          }          WiFiUDP udp;          udp.beginPacket("255.255.255.255", 9);          udp.write(magicPacket, sizeof(magicPacket));          udp.endPacket();          ESP_LOGI("WOL", "Wake-on-LAN packet sent to: %s", mac_str.c_str());sensor:  - platform: uptime    name: "Uptime"    update_interval: 60s  - platform: wifi_signal    name: "WiFi Signal"    update_interval: 60stime:  - platform: homeassistant    id: homeassistant_timetext:  - platform: template    name: "Target MAC Address"    id: mac_input    optimistic: true    max_length: 17    mode: text    initial_value: "${default_mac}"    on_value:      then:        - lambda: |-            if (id(mac_input).state.length() == 17) {              id(target_mac) = id(mac_input).state;              ESP_LOGI("MAC", "Target MAC updated to: %s", id(mac_input).state.c_str());            }            }